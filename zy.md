**题一答案：**

**备注：本题考点为var、let、const作用域问题。**

**打印出的结果是10。**

**原因为变量`i`是用`var`命令声明的，在全局范围内都有效，所以全局只有一个变量`i`。每一次循环，变量`i`的值都会发生改变，而循环内被赋给数组`a`的函数内部的console.log(i)`，里面的`i`指向的就是全局的`i`。也就是说，所有数组`a`的成员里面的`i`，指向的都是同一个`i`，导致运行时输出的是最后一轮的`i`的值，也就是 10。**

**`所以总结一点：for`循环的计数器，很合适使用`let`或 const 命令。如果使用`let`或 const，声明的变量仅在块级作用域内有效。**





**题二答案：**

**备注：本题考点为变量提升和暂时性死区。**

**会报错ReferenceError。**

**原因为只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。本题中，存在用var声明的全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域。在let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”，只要用到该变量就会报错。所以在`let`声明变量前，对`tmp`赋值会报错。**





**题目三答案：**

**备注：本题考点为js求最小值函数和es6拓展运算符...。**

**console.log(Math.min(...arr));**

**拓展运算符...可以将一个数组转为用逗号分隔的参数序列。**





**题目四答案：**

**`var`命令声明变量，在全局范围内都有效。`var`命令会发生“变量提升”现象，即变量可以在声明之前使用，值为`undefined`。**

**ES6 新增了块级作用域`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。`let`命令不允许在相同作用域内，重复声明同一个变量。let改变了var的变量提升行为，用`let`命令声明，不会发生变量提升。只要块级作用域内存在`let`命令，它所声明的变量绑定这个区域，不再受外部的影响。使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。它所声明的变量一定要在声明后使用，否则报错。**

**const`声明一个只读的常量。一旦声明，常量的值就不能改变。`const`声明的变量不得改变值，这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。`const`声明的常量，也与`let`一样不可重复声明。**

**ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。**





**题目五答案：**

**备注：本题主考箭头函数this指向问题。**

**输出20，原因为箭头函数没有自己的this，导致内部的this就是外层代码块的this。箭头函数的this看外层是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。此题中箭头函数this外层是函数，故箭头函数this指向obj，所以是object里面的a=20。**



**题目六答案：**

**备注：本题主考Symbol定义与用途。**

**Symbol是js语言的第七种数据类型，表示独一无二的值。可以成为对象的属性名类型。凡是属性名属于Symbol类型，就是独一无二的，可以保证不会与其他属性名产生冲突。**





**题目七答案：**

**备注：本题主考浅拷贝、深拷贝定义与区别。**

**JavaScript的数据类型分为基本数据类型和引用数据类型。**

**对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于引用数据类型而言的。浅拷贝和深拷贝都是对于JS中的引用类型而言的，浅拷贝就只是复制对象的引用，如果拷贝后的对象发生变化，原对象也会发生变化。只有深拷贝才是真正地对对象的拷贝。**

**浅拷贝的意思就是只复制引用，而未复制真正的值。**

**深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。目前实现深拷贝的方法不多，主要是两种：**

1. **利用 JSON 对象中的 parse 和 stringify**

2. **利用递归来实现每一层都重新创建对象并赋值**







**题目八答案：**

**js是单线程语言，如果某个同步任务工作量大，耗时长，会导致卡死现象，给用户造成很不好的体验。异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。**

**eventloop的概念与理解：**

**异步执行的运行机制如下：**

**（1）所有同步任务都在主线程上执行，形成一个执行栈。**

**（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。**

**（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。**

**（4）主线程不断重复上面的第三步。**

**主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。**

**宏任务：所有主线程上执行的任务（除了异步函数以外的所有任务）。宏任务一般是：包括整体代码script，setTimeout，setInterval。**

**微任务：异步任务。微任务：Promise，process.nextTick。**

**js执行过程：**
 **1.首先执行宏任务，当执行宏任务的时候，发现有定时器任务的时候，会将定时器添加到宏任务的任务队列里面，**
 **2.继续完成宏任务，**
 **3.当宏任务完成后，会检测是否有微任务，如果有，则执行微任务**
 **4.执行完微任务后回到宏任务**
 **5.检查任务队列里面有没有未完成的任务队列**
 **6.如果有，则执行，结束。**
 **7.如果没有，结束js脚本的执行**





**题目九答案：**

**var p1 = new Promise(function(resolve,reject){**
			**setTimeout(function(){**
				**console.log("hello")**
				**resolve(5);	  //异步操作的结果为fulfilled时的，成功回调函数。**
			**},10)**
		**})**		

****

		p1.then(function(a){
				//console.log(a);	//输出结果5.
			var p2 =  new Promise(function(resolve,reject){
				setTimeout(function(){
					console.log("lagou");
					resolve();
				},10)
			})
			return p2;
			
		}).then(function(){
			var p3 =  new Promise(function(resolve,reject){
				setTimeout(function(){
					console.log("I love you")		
				},10)
			})
		})




**题目十答案：**

**Typescript是js的超级，由js+EcmaScript新特性+类型体系的构成。Typescript完善了js弱类型的问题。**



**题目十一答案：**

**ts优点：**

**1、类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了。**

**2、可以在编译阶段就发现大部分错误，这总比在运行时候出错好。**

**3、即使不显式的定义类型，也能够自动做出类型推论。**

**4、即使 TypeScript 编译报错，也可以生成 JavaScript 文件。**

**5、可以使用ecmascript最新特性。**

**6、可以用来开发vue、angular等第三方库。**

**ts缺点：**

**1、有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念。**

**2、短期可能会增加一些开发成本，要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本。**

**3、集成到构建流程需要一些工作量。**

**4、可能和一些库结合的不是很完美。**